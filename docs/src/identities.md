# Identities

Apart from your nodes external IP and port, p2p applications typically instill that each node should have some sort of publicly verifiable identity.

The identity could comprise of all sorts of things: from a string of random bytes to a cryptographically verifiable identity.

Most likely, you would want a cryptographic ID for your node.

As of right now, there exists a few identity schemes which Noise provides built-in support for that you may use on the get-go for your p2p application:

1. Ed25519 identities
2. S/Kademlia-compatible Ed25519 identities

You may additionally create/implement your own identity schemes that any node/peer may support in Noise by simply having your scheme implement the following interface:

```go
package identity

import "fmt"

type Keypair interface {
	fmt.Stringer

	ID() []byte
	PublicKey() []byte
	PrivateKey() []byte
}
```

Should the identity scheme you wish to implement not have any sort of `PrivateKey()` or `PublicKey()` or `ID()` associated to it, you may simply stub out those functions and ignore their implementation.

After picking/implementing an identity scheme of your choice for your p2p application, it is simple to have your node adopt it as follows:

```go
import (
	"github.com/perlin-network/noise"
	"github.com/perlin-network/noise/identity/ed25519"
	"github.com/perlin-network/noise/skademlia"
)

params := noise.DefaultParams()

// Generate a random Ed25519 keypair w/ EdDSA signature scheme support
// for your node.
params.Keys = ed25519.RandomKeys()

// Generate a random S/Kademlia-compatible Ed25519 keypair w/ EdDSA 
// signature scheme support for your node.
params.Keys = skademlia.RandomKeys()

// Load an existing Ed25519 keypair for your node.
params.Keys = ed25519.LoadKeys([]byte{...})

// Load an existing S/Kademlia-compatible keypair for your node.
// Wondering what C1 and C2 are for? Check out S/Kademlia's documentation!
params.Keys = skademlia.LoadKeys([]byte{...}, skademlia.DefaultC1, skademlia.DefaultC2)
```

## Signing/Verifying Messages

Signature schemes are stubbed out into an interface which you could implement to integrate
cryptographic signatures into supported protocol building blocks Noise provides.

All signature schemes implement the following interface:

```go
type Scheme interface {
	Sign(privateKey, messageBuf []byte) ([]byte, error)
	Verify(publicKeyBuf, messageBuf, signatureBuf []byte) error
}
```

As of right now, Noise provides off-the-shelf the following signature schemes:
- EdDSA Signature Scheme (assembly-optimized)

You may use a signature scheme to sign/verify raw arrays of bytes to see
whether or not a signature was generated by a specified public key like so:

```go
import "github.com/perlin-network/noise/signature/eddsa"

var node *noise.Node

message := "We're going to sign this message with our node!"

// Sign a message using the EdDSA signature scheme.
signature, err := eddsa.Sign(node.Keys.PrivateKey(), []byte(message))
if err != nil {
	panic("failed to sign the message")
}

fmt.Println("Signature:", signature)

// Now let's verify that the signature is under our own nodes identity!

fmt.Println("Is the signature valid?", 
	eddsa.Verify(node.Keys.PublicKey(), []byte(message), signature))
```